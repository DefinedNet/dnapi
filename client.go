// Package dnapi handles communication with the Defined Networking cloud API server.
package dnapi

import (
	"bytes"
	"context"
	"crypto/ed25519"
	"encoding/json"
	"fmt"
	"io"
	"net"
	"net/http"
	"net/url"
	"sync/atomic"
	"time"

	"github.com/DefinedNet/dnapi/message"
	"github.com/sirupsen/logrus"
	"github.com/slackhq/nebula/cert"
)

// Client communicates with the API server.
type Client struct {
	dnServer string

	client          *http.Client
	streamingClient *http.Client
}

// NewClient returns new Client configured with the given useragent.
// It also supports reading Proxy information from the environment.
func NewClient(useragent string, dnServer string) *Client {
	return &Client{
		client: &http.Client{
			Timeout: 2 * time.Minute,
			Transport: &uaTransport{
				T: &http.Transport{
					Proxy:               http.ProxyFromEnvironment,
					TLSHandshakeTimeout: 10 * time.Second,
					DialContext: (&net.Dialer{
						Timeout: 10 * time.Second,
					}).DialContext,
				},
				useragent: useragent,
			},
		},
		streamingClient: &http.Client{
			Timeout: 15 * time.Minute,
			Transport: &uaTransport{
				T: &http.Transport{
					Proxy:               http.ProxyFromEnvironment,
					TLSHandshakeTimeout: 10 * time.Second,
					DialContext: (&net.Dialer{
						Timeout: 10 * time.Second,
					}).DialContext,
				},
				useragent: useragent,
			},
		},
		dnServer: dnServer,
	}
}

// APIError wraps an error and contains the RequestID from the X-Request-ID
// header of an API response. ReqID defaults to empty string  if the header is
// not in the response.
type APIError struct {
	e     error
	ReqID string
}

func (e *APIError) Error() string {
	return e.e.Error()
}

func (e *APIError) Unwrap() error {
	return e.e
}

type InvalidCredentialsError struct{}

func (e InvalidCredentialsError) Error() string {
	return "invalid credentials"
}

type EnrollMeta struct {
	OrganizationID   string
	OrganizationName string
}

// Enroll issues an enrollment request against the REST API using the given enrollment code, passing along a locally
// generated DH X25519 public key to be signed by the CA, and an Ed 25519 public key for future API call authentication.
// On success it returns the Nebula config generated by the server, a Nebula private key PEM to be inserted into the
// config (see api.InsertConfigPrivateKey), credentials to be used in DNClient API requests, and a meta object
// containing organization info.
func (c *Client) Enroll(ctx context.Context, logger logrus.FieldLogger, code string) ([]byte, []byte, *Credentials, *EnrollMeta, error) {
	logger.WithFields(logrus.Fields{"server": c.dnServer}).Debug("Making enrollment request to API")

	// Generate initial Ed25519 keypair for API communication
	keys, err := newKeys()
	if err != nil {
		return nil, nil, nil, nil, err
	}

	hostPubkeyP256, err := MarshalECDSAP256PublicKey(keys.ecdsaP256PublicKey)
	if err != nil {
		return nil, nil, nil, nil, err
	}

	// Make a request to the API with the enrollment code
	jv, err := json.Marshal(message.EnrollRequest{
		Code:               code,
		NebulaPubkeyX25519: keys.x25519PublicKeyPEM,
		HostPubkeyEd25519:  cert.MarshalEd25519PublicKey(ed25519.PublicKey(keys.ed25519PublicKey)),
		NebulaPubkeyP256:   keys.ecdhP256PublicKeyPEM,
		HostPubkeyP256:     hostPubkeyP256,
		Timestamp:          time.Now(),
	})
	if err != nil {
		return nil, nil, nil, nil, err
	}
	enrollURL, err := url.JoinPath(c.dnServer, message.EnrollEndpoint)
	if err != nil {
		return nil, nil, nil, nil, err
	}
	req, err := http.NewRequestWithContext(ctx, "POST", enrollURL, bytes.NewBuffer(jv))
	if err != nil {
		return nil, nil, nil, nil, err
	}

	resp, err := c.client.Do(req)
	if err != nil {
		return nil, nil, nil, nil, err
	}
	defer resp.Body.Close()

	// Log the request ID returned from the server
	reqID := resp.Header.Get("X-Request-ID")
	l := logger.WithFields(logrus.Fields{"statusCode": resp.StatusCode, "reqID": reqID})
	if resp.StatusCode == http.StatusOK {
		l.Info("Enrollment request returned success code")
	} else {
		l.Error("Enrollment request returned error code")
	}

	// Decode the response
	r := message.EnrollResponse{}
	b, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, nil, nil, nil, &APIError{e: fmt.Errorf("error reading response body: %s", err), ReqID: reqID}
	}

	if err := json.Unmarshal(b, &r); err != nil {
		return nil, nil, nil, nil, &APIError{e: fmt.Errorf("error decoding JSON response: %s\nbody: %s", err, b), ReqID: reqID}
	}

	// Check for any errors returned by the API
	if err := r.Errors.ToError(); err != nil {
		return nil, nil, nil, nil, &APIError{e: fmt.Errorf("unexpected error during enrollment: %v", err), ReqID: reqID}
	}

	meta := &EnrollMeta{
		OrganizationID:   r.Data.Organization.ID,
		OrganizationName: r.Data.Organization.Name,
	}

	trustedKeys, err := Ed25519PublicKeysFromPEM(r.Data.TrustedKeys)
	if err != nil {
		return nil, nil, nil, nil, &APIError{e: fmt.Errorf("failed to load trusted keys from bundle: %s", err), ReqID: reqID}
	}

	var privkeyPEM []byte
	var privkey PrivateKey
	switch {
	case r.Data.Network.Curve == message.NetworkCurve25519:
		privkeyPEM = keys.x25519PrivateKeyPEM
		privkey = Ed25519PrivateKey{keys.ed25519PrivateKey}
	case r.Data.Network.Curve == message.NetworkCurveP256:
		privkeyPEM = keys.ecdhP256PrivateKeyPEM
		privkey = P256PrivateKey{keys.ecdsaP256PrivateKey}
	default:
		return nil, nil, nil, nil, &APIError{e: fmt.Errorf("unsupported curve type: %s", r.Data.Network.Curve), ReqID: reqID}
	}

	creds := &Credentials{
		HostID:      r.Data.HostID,
		PrivateKey:  privkey,
		Counter:     r.Data.Counter,
		TrustedKeys: trustedKeys,
	}
	return r.Data.Config, privkeyPEM, creds, meta, nil
}

// CheckForUpdate sends a signed message to the DNClient API to learn if there is a new configuration available.
func (c *Client) CheckForUpdate(ctx context.Context, creds Credentials) (bool, error) {
	respBody, err := c.postDNClient(ctx, message.CheckForUpdate, nil, creds.HostID, creds.Counter, creds.PrivateKey)
	if err != nil {
		return false, fmt.Errorf("failed to post message to dnclient api: %w", err)
	}
	result := message.CheckForUpdateResponseWrapper{}
	err = json.Unmarshal(respBody, &result)
	if err != nil {
		return false, fmt.Errorf("failed to interpret API response: %s", err)
	}
	return result.Data.UpdateAvailable, nil
}

// LongPollWait sends a signed message to a DNClient API endpoint that will block, returning only
// if there is an action the client should take before the timeout (config updates, debug commands)
func (c *Client) LongPollWait(ctx context.Context, creds Credentials, supportedActions []string) (*message.LongPollWaitResponse, error) {
	value, err := json.Marshal(message.LongPollWaitRequest{
		SupportedActions: supportedActions,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to marshal DNClient message: %s", err)
	}

	respBody, err := c.postDNClient(ctx, message.LongPollWait, value, creds.HostID, creds.Counter, creds.PrivateKey)
	if err != nil {
		return nil, fmt.Errorf("failed to post message to dnclient api: %w", err)
	}
	result := message.LongPollWaitResponseWrapper{}
	err = json.Unmarshal(respBody, &result)
	if err != nil {
		return nil, fmt.Errorf("failed to interpret API response: %s", err)
	}
	return &result.Data, nil
}

// DoUpdate sends a signed message to the DNClient API to fetch the new configuration update. During this call a new
// DH X25519 keypair is generated for the new Nebula certificate as well as a new Ed25519 keypair for DNClient API
// communication. On success it returns the new config, a Nebula private key PEM to be inserted into the config (see
// api.InsertConfigPrivateKey) and new DNClient API credentials.
func (c *Client) DoUpdate(ctx context.Context, creds Credentials) ([]byte, []byte, *Credentials, error) {
	// Rotate keys
	var privkeyPEM []byte  // ECDH
	var privkey PrivateKey // ECDSA

	newKeys, err := newKeys()
	if err != nil {
		return nil, nil, nil, fmt.Errorf("failed to generate new keys: %s", err)
	}

	updateKeys := message.DoUpdateRequest{
		Nonce: nonce(),
	}
	switch creds.PrivateKey.Type() {
	case Ed25519:
		updateKeys.EdPubkeyPEM = cert.MarshalEd25519PublicKey(ed25519.PublicKey(newKeys.ed25519PublicKey))
		updateKeys.DHPubkeyPEM = newKeys.x25519PublicKeyPEM
		privkeyPEM = newKeys.x25519PrivateKeyPEM
		privkey = Ed25519PrivateKey{newKeys.ed25519PrivateKey}
	case P256:
		b, err := MarshalECDSAP256PublicKey(newKeys.ecdsaP256PublicKey)
		if err != nil {
			return nil, nil, nil, fmt.Errorf("failed to marshal ECDSA P256 public key: %s", err)
		}
		updateKeys.P256HostPubkeyPEM = b
		updateKeys.P256NebulaPubkeyPEM = newKeys.ecdhP256PublicKeyPEM
		privkeyPEM = newKeys.ecdhP256PrivateKeyPEM
		privkey = P256PrivateKey{newKeys.ecdsaP256PrivateKey}
	}

	updateKeysBlob, err := json.Marshal(updateKeys)
	if err != nil {
		return nil, nil, nil, fmt.Errorf("failed to marshal DNClient message: %s", err)
	}

	// Make API call
	resp, err := c.postDNClient(ctx, message.DoUpdate, updateKeysBlob, creds.HostID, creds.Counter, creds.PrivateKey)
	if err != nil {
		return nil, nil, nil, fmt.Errorf("failed to make API call to Defined Networking: %w", err)
	}
	resultWrapper := message.SignedResponseWrapper{}
	err = json.Unmarshal(resp, &resultWrapper)
	if err != nil {
		return nil, nil, nil, fmt.Errorf("failed to unmarshal signed response wrapper: %s", err)
	}

	// Verify the signature
	valid := false
	for _, caPubkey := range creds.TrustedKeys {
		if ed25519.Verify(caPubkey, resultWrapper.Data.Message, resultWrapper.Data.Signature) {
			valid = true
			break
		}
	}
	if !valid {
		return nil, nil, nil, fmt.Errorf("failed to verify signed API result")
	}

	// Consume the verified message
	result := message.DoUpdateResponse{}
	err = json.Unmarshal(resultWrapper.Data.Message, &result)
	if err != nil {
		return nil, nil, nil, fmt.Errorf("failed to unmarshal response (%s): %s", resultWrapper.Data.Message, err)
	}

	// Verify the nonce
	if !bytes.Equal(result.Nonce, updateKeys.Nonce) {
		return nil, nil, nil, fmt.Errorf("nonce mismatch between request (%s) and response (%s)", updateKeys.Nonce, result.Nonce)
	}

	// Verify the counter
	if result.Counter <= creds.Counter {
		return nil, nil, nil, fmt.Errorf("counter in request (%d) should be less than counter in response (%d)", creds.Counter, result.Counter)
	}

	trustedKeys, err := Ed25519PublicKeysFromPEM(result.TrustedKeys)
	if err != nil {
		return nil, nil, nil, fmt.Errorf("failed to load trusted keys from bundle: %s", err)
	}

	newCreds := &Credentials{
		HostID:      creds.HostID,
		Counter:     result.Counter,
		PrivateKey:  privkey,
		TrustedKeys: trustedKeys,
	}

	return result.Config, privkeyPEM, newCreds, nil
}

func (c *Client) CommandResponse(ctx context.Context, creds Credentials, responseToken string, response any) error {
	value, err := json.Marshal(message.CommandResponseRequest{
		ResponseToken: responseToken,
		Response:      response,
	})
	if err != nil {
		return fmt.Errorf("failed to marshal DNClient message: %s", err)
	}

	_, err = c.postDNClient(ctx, message.CommandResponse, value, creds.HostID, creds.Counter, creds.PrivateKey)
	return err
}

func (c *Client) StreamCommandResponse(ctx context.Context, creds Credentials, responseToken string) (*StreamController, error) {
	value, err := json.Marshal(message.CommandResponseRequest{
		ResponseToken: responseToken,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to marshal DNClient message: %s", err)
	}

	return c.streamingPostDNClient(ctx, message.CommandResponse, value, creds.HostID, creds.Counter, creds.PrivateKey)
}

// streamingPostDNClient wraps and signs the given dnclientRequestWrapper message, and makes a streaming API call.
// On success, it returns a StreamController to interact with the request. On error, the error is returned.
func (c *Client) streamingPostDNClient(ctx context.Context, reqType string, value []byte, hostID string, counter uint, privkey PrivateKey) (*StreamController, error) {
	pr, pw := io.Pipe()

	postBody, err := SignRequestV1(reqType, value, hostID, counter, privkey)
	if err != nil {
		return nil, err
	}
	pbb := bytes.NewBuffer(postBody)

	endpointV1URL, err := url.JoinPath(c.dnServer, message.EndpointV1)
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequestWithContext(ctx, "POST", endpointV1URL, io.MultiReader(pbb, pr))
	if err != nil {
		return nil, err
	}

	done := make(chan struct{})
	sc := &StreamController{w: pw, done: done}

	go func() {
		defer close(done)

		resp, err := c.streamingClient.Do(req)
		if err != nil {
			sc.err.Store(fmt.Errorf("failed to call dnclient endpoint: %w", err))
			return
		}
		defer resp.Body.Close()

		respBody, err := io.ReadAll(resp.Body)
		if err != nil {
			sc.err.Store(fmt.Errorf("failed to read the response body: %s", err))
		}

		switch resp.StatusCode {
		case http.StatusOK:
			sc.respBytes = respBody
		case http.StatusUnauthorized:
			sc.err.Store(InvalidCredentialsError{})
		default:
			var errors struct {
				Errors message.APIErrors
			}
			if err := json.Unmarshal(respBody, &errors); err != nil {
				sc.err.Store(fmt.Errorf("dnclient endpoint returned bad status code '%d', body: %s", resp.StatusCode, respBody))
			} else {
				sc.err.Store(errors.Errors.ToError())
			}
		}
	}()

	return sc, nil
}

// postDNClient wraps and signs the given dnclientRequestWrapper message, and makes the API call.
// On success, it returns the response message body. On error, the error is returned.
func (c *Client) postDNClient(ctx context.Context, reqType string, value []byte, hostID string, counter uint, privkey PrivateKey) ([]byte, error) {
	postBody, err := SignRequestV1(reqType, value, hostID, counter, privkey)
	if err != nil {
		return nil, err
	}

	endpointV1URL, err := url.JoinPath(c.dnServer, message.EndpointV1)
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequestWithContext(ctx, "POST", endpointV1URL, bytes.NewReader(postBody))
	if err != nil {
		return nil, err
	}
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to call dnclient endpoint: %w", err)
	}
	defer resp.Body.Close()

	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read the response body: %s", err)
	}

	switch resp.StatusCode {
	case http.StatusOK:
		return respBody, nil
	case http.StatusUnauthorized:
		return nil, InvalidCredentialsError{}
	default:
		var errors struct {
			Errors message.APIErrors
		}
		if err := json.Unmarshal(respBody, &errors); err != nil {
			return nil, fmt.Errorf("dnclient endpoint returned bad status code '%d', body: %s", resp.StatusCode, respBody)
		}
		return nil, errors.Errors.ToError()
	}
}

// StreamController is used for interacting with streaming requests to the API.
//
// When a streaming request is started in a background goroutine, a StreamController is returned to the caller to allow
// writing to the request body. The request will be sent when the caller closes the StreamController. The response body
// can be read by calling ResponseBytes, which will block until the response is received.
type StreamController struct {
	w         *io.PipeWriter
	respBytes []byte
	err       atomic.Value
	done      chan struct{}
}

// Err returns any error that occurred during the streaming request. If the request was successful, Err will return nil.
// Err should be called after Close to ensure the request has completed.
func (sc *StreamController) Err() error {
	err := sc.err.Load()
	if err == nil {
		return nil
	}
	return err.(error)
}

// Write implements the io.Writer interface for StreamController. It writes to the request body. If the StreamController
// has already encountered an error, it will be returned and nothing will be written.
func (sc *StreamController) Write(p []byte) (int, error) {
	if sc.Err() != nil {
		return 0, sc.Err()
	}

	n, err := sc.w.Write(p)
	if err != nil {
		sc.err.Store(err)
	}
	return n, err
}

// Close closes the StreamController, signaling that the request body is complete and the response can be read.
func (sc *StreamController) Close() error {
	err := sc.w.Close()
	<-sc.done
	return err
}

// ResponseBytes blocks until the response is received, then returns the response body. If an error occurred during the
// request, ResponseBytes will return the error.
func (sc *StreamController) ResponseBytes() ([]byte, error) {
	<-sc.done
	if sc.Err() != nil {
		return nil, sc.Err()
	}
	return sc.respBytes, nil
}

// uaTransport wraps an http.RoundTripper and sets the User-Agent header on all requests.
type uaTransport struct {
	useragent string
	T         http.RoundTripper
}

func (t *uaTransport) RoundTrip(req *http.Request) (*http.Response, error) {
	req.Header.Set("User-Agent", t.useragent)
	return t.T.RoundTrip(req)
}
